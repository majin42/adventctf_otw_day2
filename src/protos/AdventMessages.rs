// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `AdventMessages.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub retrieve: ::protobuf::SingularPtrField<Response_Retrieve>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .Response.Retrieve retrieve = 3;


    pub fn get_retrieve(&self) -> &Response_Retrieve {
        self.retrieve.as_ref().unwrap_or_else(|| Response_Retrieve::default_instance())
    }
    pub fn clear_retrieve(&mut self) {
        self.retrieve.clear();
    }

    pub fn has_retrieve(&self) -> bool {
        self.retrieve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retrieve(&mut self, v: Response_Retrieve) {
        self.retrieve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retrieve(&mut self) -> &mut Response_Retrieve {
        if self.retrieve.is_none() {
            self.retrieve.set_default();
        }
        self.retrieve.as_mut().unwrap()
    }

    // Take field
    pub fn take_retrieve(&mut self) -> Response_Retrieve {
        self.retrieve.take().unwrap_or_else(|| Response_Retrieve::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        for v in &self.retrieve {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retrieve)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.retrieve.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.retrieve.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_Retrieve>>(
                    "retrieve",
                    |m: &Response| { &m.retrieve },
                    |m: &mut Response| { &mut m.retrieve },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response,
        };
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.retrieve.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_Retrieve {
    // message fields
    pub f1: ::protobuf::SingularPtrField<Response_Retrieve_AAA>,
    pub inventory: ::protobuf::SingularPtrField<Response_Retrieve_Inventory>,
    pub f3: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_Retrieve {
    fn default() -> &'a Response_Retrieve {
        <Response_Retrieve as ::protobuf::Message>::default_instance()
    }
}

impl Response_Retrieve {
    pub fn new() -> Response_Retrieve {
        ::std::default::Default::default()
    }

    // .Response.Retrieve.AAA f1 = 1;


    pub fn get_f1(&self) -> &Response_Retrieve_AAA {
        self.f1.as_ref().unwrap_or_else(|| Response_Retrieve_AAA::default_instance())
    }
    pub fn clear_f1(&mut self) {
        self.f1.clear();
    }

    pub fn has_f1(&self) -> bool {
        self.f1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: Response_Retrieve_AAA) {
        self.f1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_f1(&mut self) -> &mut Response_Retrieve_AAA {
        if self.f1.is_none() {
            self.f1.set_default();
        }
        self.f1.as_mut().unwrap()
    }

    // Take field
    pub fn take_f1(&mut self) -> Response_Retrieve_AAA {
        self.f1.take().unwrap_or_else(|| Response_Retrieve_AAA::new())
    }

    // .Response.Retrieve.Inventory inventory = 2;


    pub fn get_inventory(&self) -> &Response_Retrieve_Inventory {
        self.inventory.as_ref().unwrap_or_else(|| Response_Retrieve_Inventory::default_instance())
    }
    pub fn clear_inventory(&mut self) {
        self.inventory.clear();
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: Response_Retrieve_Inventory) {
        self.inventory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inventory(&mut self) -> &mut Response_Retrieve_Inventory {
        if self.inventory.is_none() {
            self.inventory.set_default();
        }
        self.inventory.as_mut().unwrap()
    }

    // Take field
    pub fn take_inventory(&mut self) -> Response_Retrieve_Inventory {
        self.inventory.take().unwrap_or_else(|| Response_Retrieve_Inventory::new())
    }

    // uint64 f3 = 3;


    pub fn get_f3(&self) -> u64 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: u64) {
        self.f3 = v;
    }
}

impl ::protobuf::Message for Response_Retrieve {
    fn is_initialized(&self) -> bool {
        for v in &self.f1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventory {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.f1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inventory)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.f3 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.f1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inventory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.f1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inventory.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.f3 != 0 {
            os.write_uint64(3, self.f3)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_Retrieve {
        Response_Retrieve::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_Retrieve_AAA>>(
                    "f1",
                    |m: &Response_Retrieve| { &m.f1 },
                    |m: &mut Response_Retrieve| { &mut m.f1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_Retrieve_Inventory>>(
                    "inventory",
                    |m: &Response_Retrieve| { &m.inventory },
                    |m: &mut Response_Retrieve| { &mut m.inventory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f3",
                    |m: &Response_Retrieve| { &m.f3 },
                    |m: &mut Response_Retrieve| { &mut m.f3 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response_Retrieve>(
                    "Response_Retrieve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response_Retrieve {
        static mut instance: ::protobuf::lazy::Lazy<Response_Retrieve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response_Retrieve,
        };
        unsafe {
            instance.get(Response_Retrieve::new)
        }
    }
}

impl ::protobuf::Clear for Response_Retrieve {
    fn clear(&mut self) {
        self.f1.clear();
        self.inventory.clear();
        self.f3 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_Retrieve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_Retrieve {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_Retrieve_AAA {
    // message fields
    pub f1: u64,
    pub f3: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_Retrieve_AAA {
    fn default() -> &'a Response_Retrieve_AAA {
        <Response_Retrieve_AAA as ::protobuf::Message>::default_instance()
    }
}

impl Response_Retrieve_AAA {
    pub fn new() -> Response_Retrieve_AAA {
        ::std::default::Default::default()
    }

    // uint64 f1 = 1;


    pub fn get_f1(&self) -> u64 {
        self.f1
    }
    pub fn clear_f1(&mut self) {
        self.f1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: u64) {
        self.f1 = v;
    }

    // uint64 f3 = 3;


    pub fn get_f3(&self) -> u64 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: u64) {
        self.f3 = v;
    }
}

impl ::protobuf::Message for Response_Retrieve_AAA {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.f1 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.f3 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.f1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.f1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.f1 != 0 {
            os.write_uint64(1, self.f1)?;
        }
        if self.f3 != 0 {
            os.write_uint64(3, self.f3)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_Retrieve_AAA {
        Response_Retrieve_AAA::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f1",
                    |m: &Response_Retrieve_AAA| { &m.f1 },
                    |m: &mut Response_Retrieve_AAA| { &mut m.f1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f3",
                    |m: &Response_Retrieve_AAA| { &m.f3 },
                    |m: &mut Response_Retrieve_AAA| { &mut m.f3 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response_Retrieve_AAA>(
                    "Response_Retrieve_AAA",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response_Retrieve_AAA {
        static mut instance: ::protobuf::lazy::Lazy<Response_Retrieve_AAA> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response_Retrieve_AAA,
        };
        unsafe {
            instance.get(Response_Retrieve_AAA::new)
        }
    }
}

impl ::protobuf::Clear for Response_Retrieve_AAA {
    fn clear(&mut self) {
        self.f1 = 0;
        self.f3 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_Retrieve_AAA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_Retrieve_AAA {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_Retrieve_Inventory {
    // message fields
    pub items: ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item>,
    pub f3: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_Retrieve_Inventory {
    fn default() -> &'a Response_Retrieve_Inventory {
        <Response_Retrieve_Inventory as ::protobuf::Message>::default_instance()
    }
}

impl Response_Retrieve_Inventory {
    pub fn new() -> Response_Retrieve_Inventory {
        ::std::default::Default::default()
    }

    // repeated .Response.Retrieve.Inventory.Item items = 2;


    pub fn get_items(&self) -> &[Response_Retrieve_Inventory_Item] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // uint64 f3 = 3;


    pub fn get_f3(&self) -> u64 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: u64) {
        self.f3 = v;
    }
}

impl ::protobuf::Message for Response_Retrieve_Inventory {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.f3 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.f3 != 0 {
            os.write_uint64(3, self.f3)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_Retrieve_Inventory {
        Response_Retrieve_Inventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_Retrieve_Inventory_Item>>(
                    "items",
                    |m: &Response_Retrieve_Inventory| { &m.items },
                    |m: &mut Response_Retrieve_Inventory| { &mut m.items },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f3",
                    |m: &Response_Retrieve_Inventory| { &m.f3 },
                    |m: &mut Response_Retrieve_Inventory| { &mut m.f3 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response_Retrieve_Inventory>(
                    "Response_Retrieve_Inventory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response_Retrieve_Inventory {
        static mut instance: ::protobuf::lazy::Lazy<Response_Retrieve_Inventory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response_Retrieve_Inventory,
        };
        unsafe {
            instance.get(Response_Retrieve_Inventory::new)
        }
    }
}

impl ::protobuf::Clear for Response_Retrieve_Inventory {
    fn clear(&mut self) {
        self.items.clear();
        self.f3 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_Retrieve_Inventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_Retrieve_Inventory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_Retrieve_Inventory_Item {
    // message fields
    pub id: u64,
    pub f2: u64,
    pub f3: u64,
    pub f4: ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item_AABAD>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_Retrieve_Inventory_Item {
    fn default() -> &'a Response_Retrieve_Inventory_Item {
        <Response_Retrieve_Inventory_Item as ::protobuf::Message>::default_instance()
    }
}

impl Response_Retrieve_Inventory_Item {
    pub fn new() -> Response_Retrieve_Inventory_Item {
        ::std::default::Default::default()
    }

    // uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // uint64 f2 = 2;


    pub fn get_f2(&self) -> u64 {
        self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: u64) {
        self.f2 = v;
    }

    // uint64 f3 = 3;


    pub fn get_f3(&self) -> u64 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: u64) {
        self.f3 = v;
    }

    // repeated .Response.Retrieve.Inventory.Item.AABAD f4 = 4;


    pub fn get_f4(&self) -> &[Response_Retrieve_Inventory_Item_AABAD] {
        &self.f4
    }
    pub fn clear_f4(&mut self) {
        self.f4.clear();
    }

    // Param is passed by value, moved
    pub fn set_f4(&mut self, v: ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item_AABAD>) {
        self.f4 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_f4(&mut self) -> &mut ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item_AABAD> {
        &mut self.f4
    }

    // Take field
    pub fn take_f4(&mut self) -> ::protobuf::RepeatedField<Response_Retrieve_Inventory_Item_AABAD> {
        ::std::mem::replace(&mut self.f4, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Response_Retrieve_Inventory_Item {
    fn is_initialized(&self) -> bool {
        for v in &self.f4 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.f2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.f3 = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.f4)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.f4 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.f2 != 0 {
            os.write_uint64(2, self.f2)?;
        }
        if self.f3 != 0 {
            os.write_uint64(3, self.f3)?;
        }
        for v in &self.f4 {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_Retrieve_Inventory_Item {
        Response_Retrieve_Inventory_Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "id",
                    |m: &Response_Retrieve_Inventory_Item| { &m.id },
                    |m: &mut Response_Retrieve_Inventory_Item| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f2",
                    |m: &Response_Retrieve_Inventory_Item| { &m.f2 },
                    |m: &mut Response_Retrieve_Inventory_Item| { &mut m.f2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f3",
                    |m: &Response_Retrieve_Inventory_Item| { &m.f3 },
                    |m: &mut Response_Retrieve_Inventory_Item| { &mut m.f3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_Retrieve_Inventory_Item_AABAD>>(
                    "f4",
                    |m: &Response_Retrieve_Inventory_Item| { &m.f4 },
                    |m: &mut Response_Retrieve_Inventory_Item| { &mut m.f4 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response_Retrieve_Inventory_Item>(
                    "Response_Retrieve_Inventory_Item",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response_Retrieve_Inventory_Item {
        static mut instance: ::protobuf::lazy::Lazy<Response_Retrieve_Inventory_Item> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response_Retrieve_Inventory_Item,
        };
        unsafe {
            instance.get(Response_Retrieve_Inventory_Item::new)
        }
    }
}

impl ::protobuf::Clear for Response_Retrieve_Inventory_Item {
    fn clear(&mut self) {
        self.id = 0;
        self.f2 = 0;
        self.f3 = 0;
        self.f4.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_Retrieve_Inventory_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_Retrieve_Inventory_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_Retrieve_Inventory_Item_AABAD {
    // message fields
    pub f1: ::std::vec::Vec<u64>,
    pub f2: ::std::vec::Vec<u64>,
    pub f3: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_Retrieve_Inventory_Item_AABAD {
    fn default() -> &'a Response_Retrieve_Inventory_Item_AABAD {
        <Response_Retrieve_Inventory_Item_AABAD as ::protobuf::Message>::default_instance()
    }
}

impl Response_Retrieve_Inventory_Item_AABAD {
    pub fn new() -> Response_Retrieve_Inventory_Item_AABAD {
        ::std::default::Default::default()
    }

    // repeated uint64 f1 = 1;


    pub fn get_f1(&self) -> &[u64] {
        &self.f1
    }
    pub fn clear_f1(&mut self) {
        self.f1.clear();
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: ::std::vec::Vec<u64>) {
        self.f1 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_f1(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.f1
    }

    // Take field
    pub fn take_f1(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.f1, ::std::vec::Vec::new())
    }

    // repeated uint64 f2 = 2;


    pub fn get_f2(&self) -> &[u64] {
        &self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2.clear();
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: ::std::vec::Vec<u64>) {
        self.f2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_f2(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.f2
    }

    // Take field
    pub fn take_f2(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.f2, ::std::vec::Vec::new())
    }

    // repeated uint64 f3 = 3;


    pub fn get_f3(&self) -> &[u64] {
        &self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3.clear();
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: ::std::vec::Vec<u64>) {
        self.f3 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_f3(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.f3
    }

    // Take field
    pub fn take_f3(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.f3, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_Retrieve_Inventory_Item_AABAD {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.f1)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.f2)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.f3)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.f1 {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.f2 {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.f3 {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.f1 {
            os.write_uint64(1, *v)?;
        };
        for v in &self.f2 {
            os.write_uint64(2, *v)?;
        };
        for v in &self.f3 {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_Retrieve_Inventory_Item_AABAD {
        Response_Retrieve_Inventory_Item_AABAD::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f1",
                    |m: &Response_Retrieve_Inventory_Item_AABAD| { &m.f1 },
                    |m: &mut Response_Retrieve_Inventory_Item_AABAD| { &mut m.f1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f2",
                    |m: &Response_Retrieve_Inventory_Item_AABAD| { &m.f2 },
                    |m: &mut Response_Retrieve_Inventory_Item_AABAD| { &mut m.f2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "f3",
                    |m: &Response_Retrieve_Inventory_Item_AABAD| { &m.f3 },
                    |m: &mut Response_Retrieve_Inventory_Item_AABAD| { &mut m.f3 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response_Retrieve_Inventory_Item_AABAD>(
                    "Response_Retrieve_Inventory_Item_AABAD",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response_Retrieve_Inventory_Item_AABAD {
        static mut instance: ::protobuf::lazy::Lazy<Response_Retrieve_Inventory_Item_AABAD> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response_Retrieve_Inventory_Item_AABAD,
        };
        unsafe {
            instance.get(Response_Retrieve_Inventory_Item_AABAD::new)
        }
    }
}

impl ::protobuf::Clear for Response_Retrieve_Inventory_Item_AABAD {
    fn clear(&mut self) {
        self.f1.clear();
        self.f2.clear();
        self.f3.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_Retrieve_Inventory_Item_AABAD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_Retrieve_Inventory_Item_AABAD {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action {
    // message fields
    pub login: ::protobuf::SingularPtrField<Action_Login>,
    pub fight: ::protobuf::SingularPtrField<Action_Fight>,
    pub inventory: ::protobuf::SingularPtrField<Action_Inventory>,
    pub field_use: ::protobuf::SingularPtrField<Action_Use>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action {
    fn default() -> &'a Action {
        <Action as ::protobuf::Message>::default_instance()
    }
}

impl Action {
    pub fn new() -> Action {
        ::std::default::Default::default()
    }

    // .Action.Login login = 2;


    pub fn get_login(&self) -> &Action_Login {
        self.login.as_ref().unwrap_or_else(|| Action_Login::default_instance())
    }
    pub fn clear_login(&mut self) {
        self.login.clear();
    }

    pub fn has_login(&self) -> bool {
        self.login.is_some()
    }

    // Param is passed by value, moved
    pub fn set_login(&mut self, v: Action_Login) {
        self.login = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_login(&mut self) -> &mut Action_Login {
        if self.login.is_none() {
            self.login.set_default();
        }
        self.login.as_mut().unwrap()
    }

    // Take field
    pub fn take_login(&mut self) -> Action_Login {
        self.login.take().unwrap_or_else(|| Action_Login::new())
    }

    // .Action.Fight fight = 3;


    pub fn get_fight(&self) -> &Action_Fight {
        self.fight.as_ref().unwrap_or_else(|| Action_Fight::default_instance())
    }
    pub fn clear_fight(&mut self) {
        self.fight.clear();
    }

    pub fn has_fight(&self) -> bool {
        self.fight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fight(&mut self, v: Action_Fight) {
        self.fight = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fight(&mut self) -> &mut Action_Fight {
        if self.fight.is_none() {
            self.fight.set_default();
        }
        self.fight.as_mut().unwrap()
    }

    // Take field
    pub fn take_fight(&mut self) -> Action_Fight {
        self.fight.take().unwrap_or_else(|| Action_Fight::new())
    }

    // .Action.Inventory inventory = 4;


    pub fn get_inventory(&self) -> &Action_Inventory {
        self.inventory.as_ref().unwrap_or_else(|| Action_Inventory::default_instance())
    }
    pub fn clear_inventory(&mut self) {
        self.inventory.clear();
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: Action_Inventory) {
        self.inventory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inventory(&mut self) -> &mut Action_Inventory {
        if self.inventory.is_none() {
            self.inventory.set_default();
        }
        self.inventory.as_mut().unwrap()
    }

    // Take field
    pub fn take_inventory(&mut self) -> Action_Inventory {
        self.inventory.take().unwrap_or_else(|| Action_Inventory::new())
    }

    // .Action.Use use = 5;


    pub fn get_field_use(&self) -> &Action_Use {
        self.field_use.as_ref().unwrap_or_else(|| Action_Use::default_instance())
    }
    pub fn clear_field_use(&mut self) {
        self.field_use.clear();
    }

    pub fn has_field_use(&self) -> bool {
        self.field_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_use(&mut self, v: Action_Use) {
        self.field_use = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_use(&mut self) -> &mut Action_Use {
        if self.field_use.is_none() {
            self.field_use.set_default();
        }
        self.field_use.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_use(&mut self) -> Action_Use {
        self.field_use.take().unwrap_or_else(|| Action_Use::new())
    }
}

impl ::protobuf::Message for Action {
    fn is_initialized(&self) -> bool {
        for v in &self.login {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fight {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_use {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.login)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fight)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inventory)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_use)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.login.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inventory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_use.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.login.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fight.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inventory.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_use.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action {
        Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action_Login>>(
                    "login",
                    |m: &Action| { &m.login },
                    |m: &mut Action| { &mut m.login },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action_Fight>>(
                    "fight",
                    |m: &Action| { &m.fight },
                    |m: &mut Action| { &mut m.fight },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action_Inventory>>(
                    "inventory",
                    |m: &Action| { &m.inventory },
                    |m: &mut Action| { &mut m.inventory },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action_Use>>(
                    "use",
                    |m: &Action| { &m.field_use },
                    |m: &mut Action| { &mut m.field_use },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Action>(
                    "Action",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Action {
        static mut instance: ::protobuf::lazy::Lazy<Action> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Action,
        };
        unsafe {
            instance.get(Action::new)
        }
    }
}

impl ::protobuf::Clear for Action {
    fn clear(&mut self) {
        self.login.clear();
        self.fight.clear();
        self.inventory.clear();
        self.field_use.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action_Login {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action_Login {
    fn default() -> &'a Action_Login {
        <Action_Login as ::protobuf::Message>::default_instance()
    }
}

impl Action_Login {
    pub fn new() -> Action_Login {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Action_Login {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action_Login {
        Action_Login::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &Action_Login| { &m.username },
                    |m: &mut Action_Login| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &Action_Login| { &m.password },
                    |m: &mut Action_Login| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Action_Login>(
                    "Action_Login",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Action_Login {
        static mut instance: ::protobuf::lazy::Lazy<Action_Login> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Action_Login,
        };
        unsafe {
            instance.get(Action_Login::new)
        }
    }
}

impl ::protobuf::Clear for Action_Login {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action_Login {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action_Login {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action_Fight {
    // message fields
    pub level: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action_Fight {
    fn default() -> &'a Action_Fight {
        <Action_Fight as ::protobuf::Message>::default_instance()
    }
}

impl Action_Fight {
    pub fn new() -> Action_Fight {
        ::std::default::Default::default()
    }

    // uint64 level = 1;


    pub fn get_level(&self) -> u64 {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = 0;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u64) {
        self.level = v;
    }
}

impl ::protobuf::Message for Action_Fight {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != 0 {
            my_size += ::protobuf::rt::value_size(1, self.level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != 0 {
            os.write_uint64(1, self.level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action_Fight {
        Action_Fight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "level",
                    |m: &Action_Fight| { &m.level },
                    |m: &mut Action_Fight| { &mut m.level },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Action_Fight>(
                    "Action_Fight",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Action_Fight {
        static mut instance: ::protobuf::lazy::Lazy<Action_Fight> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Action_Fight,
        };
        unsafe {
            instance.get(Action_Fight::new)
        }
    }
}

impl ::protobuf::Clear for Action_Fight {
    fn clear(&mut self) {
        self.level = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action_Fight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action_Fight {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action_Inventory {
    // message fields
    pub retrieve_buy: u64,
    pub store_sell: u64,
    pub inventory_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action_Inventory {
    fn default() -> &'a Action_Inventory {
        <Action_Inventory as ::protobuf::Message>::default_instance()
    }
}

impl Action_Inventory {
    pub fn new() -> Action_Inventory {
        ::std::default::Default::default()
    }

    // uint64 retrieve_buy = 1;


    pub fn get_retrieve_buy(&self) -> u64 {
        self.retrieve_buy
    }
    pub fn clear_retrieve_buy(&mut self) {
        self.retrieve_buy = 0;
    }

    // Param is passed by value, moved
    pub fn set_retrieve_buy(&mut self, v: u64) {
        self.retrieve_buy = v;
    }

    // uint64 store_sell = 2;


    pub fn get_store_sell(&self) -> u64 {
        self.store_sell
    }
    pub fn clear_store_sell(&mut self) {
        self.store_sell = 0;
    }

    // Param is passed by value, moved
    pub fn set_store_sell(&mut self, v: u64) {
        self.store_sell = v;
    }

    // uint64 inventory_id = 3;


    pub fn get_inventory_id(&self) -> u64 {
        self.inventory_id
    }
    pub fn clear_inventory_id(&mut self) {
        self.inventory_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_inventory_id(&mut self, v: u64) {
        self.inventory_id = v;
    }
}

impl ::protobuf::Message for Action_Inventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.retrieve_buy = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.store_sell = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.inventory_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.retrieve_buy != 0 {
            my_size += ::protobuf::rt::value_size(1, self.retrieve_buy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.store_sell != 0 {
            my_size += ::protobuf::rt::value_size(2, self.store_sell, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inventory_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.inventory_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.retrieve_buy != 0 {
            os.write_uint64(1, self.retrieve_buy)?;
        }
        if self.store_sell != 0 {
            os.write_uint64(2, self.store_sell)?;
        }
        if self.inventory_id != 0 {
            os.write_uint64(3, self.inventory_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action_Inventory {
        Action_Inventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "retrieve_buy",
                    |m: &Action_Inventory| { &m.retrieve_buy },
                    |m: &mut Action_Inventory| { &mut m.retrieve_buy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "store_sell",
                    |m: &Action_Inventory| { &m.store_sell },
                    |m: &mut Action_Inventory| { &mut m.store_sell },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "inventory_id",
                    |m: &Action_Inventory| { &m.inventory_id },
                    |m: &mut Action_Inventory| { &mut m.inventory_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Action_Inventory>(
                    "Action_Inventory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Action_Inventory {
        static mut instance: ::protobuf::lazy::Lazy<Action_Inventory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Action_Inventory,
        };
        unsafe {
            instance.get(Action_Inventory::new)
        }
    }
}

impl ::protobuf::Clear for Action_Inventory {
    fn clear(&mut self) {
        self.retrieve_buy = 0;
        self.store_sell = 0;
        self.inventory_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action_Inventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action_Inventory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action_Use {
    // message fields
    pub inventory_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action_Use {
    fn default() -> &'a Action_Use {
        <Action_Use as ::protobuf::Message>::default_instance()
    }
}

impl Action_Use {
    pub fn new() -> Action_Use {
        ::std::default::Default::default()
    }

    // uint64 inventory_id = 2;


    pub fn get_inventory_id(&self) -> u64 {
        self.inventory_id
    }
    pub fn clear_inventory_id(&mut self) {
        self.inventory_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_inventory_id(&mut self, v: u64) {
        self.inventory_id = v;
    }
}

impl ::protobuf::Message for Action_Use {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.inventory_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.inventory_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.inventory_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.inventory_id != 0 {
            os.write_uint64(2, self.inventory_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action_Use {
        Action_Use::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "inventory_id",
                    |m: &Action_Use| { &m.inventory_id },
                    |m: &mut Action_Use| { &mut m.inventory_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Action_Use>(
                    "Action_Use",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Action_Use {
        static mut instance: ::protobuf::lazy::Lazy<Action_Use> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Action_Use,
        };
        unsafe {
            instance.get(Action_Use::new)
        }
    }
}

impl ::protobuf::Clear for Action_Use {
    fn clear(&mut self) {
        self.inventory_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action_Use {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action_Use {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14AdventMessages.proto\"\xe4\x03\n\x08Response\x12.\n\x08retrieve\
    \x18\x03\x20\x01(\x0b2\x12.Response.RetrieveR\x08retrieve\x1a\xa7\x03\n\
    \x08Retrieve\x12&\n\x02f1\x18\x01\x20\x01(\x0b2\x16.Response.Retrieve.AA\
    AR\x02f1\x12:\n\tinventory\x18\x02\x20\x01(\x0b2\x1c.Response.Retrieve.I\
    nventoryR\tinventory\x12\x0e\n\x02f3\x18\x03\x20\x01(\x04R\x02f3\x1a%\n\
    \x03AAA\x12\x0e\n\x02f1\x18\x01\x20\x01(\x04R\x02f1\x12\x0e\n\x02f3\x18\
    \x03\x20\x01(\x04R\x02f3\x1a\xff\x01\n\tInventory\x127\n\x05items\x18\
    \x02\x20\x03(\x0b2!.Response.Retrieve.Inventory.ItemR\x05items\x12\x0e\n\
    \x02f3\x18\x03\x20\x01(\x04R\x02f3\x1a\xa8\x01\n\x04Item\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x04R\x02id\x12\x0e\n\x02f2\x18\x02\x20\x01(\x04R\x02f2\
    \x12\x0e\n\x02f3\x18\x03\x20\x01(\x04R\x02f3\x127\n\x02f4\x18\x04\x20\
    \x03(\x0b2'.Response.Retrieve.Inventory.Item.AABADR\x02f4\x1a7\n\x05AABA\
    D\x12\x0e\n\x02f1\x18\x01\x20\x03(\x04R\x02f1\x12\x0e\n\x02f2\x18\x02\
    \x20\x03(\x04R\x02f2\x12\x0e\n\x02f3\x18\x03\x20\x03(\x04R\x02f3\"\x9e\
    \x03\n\x06Action\x12#\n\x05login\x18\x02\x20\x01(\x0b2\r.Action.LoginR\
    \x05login\x12#\n\x05fight\x18\x03\x20\x01(\x0b2\r.Action.FightR\x05fight\
    \x12/\n\tinventory\x18\x04\x20\x01(\x0b2\x11.Action.InventoryR\tinventor\
    y\x12\x1d\n\x03use\x18\x05\x20\x01(\x0b2\x0b.Action.UseR\x03use\x1a?\n\
    \x05Login\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\x1a\
    \n\x08password\x18\x02\x20\x01(\tR\x08password\x1a\x1d\n\x05Fight\x12\
    \x14\n\x05level\x18\x01\x20\x01(\x04R\x05level\x1ap\n\tInventory\x12!\n\
    \x0cretrieve_buy\x18\x01\x20\x01(\x04R\x0bretrieveBuy\x12\x1d\n\nstore_s\
    ell\x18\x02\x20\x01(\x04R\tstoreSell\x12!\n\x0cinventory_id\x18\x03\x20\
    \x01(\x04R\x0binventoryId\x1a(\n\x03Use\x12!\n\x0cinventory_id\x18\x02\
    \x20\x01(\x04R\x0binventoryIdb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
